@page "/gloser"
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

@using WebGloser.Model;
@using System.Timers;
@using BlazorClient.Services;
@using static BlazorClient.Shared.Misc;

@code {
    string __version = "2.6.0: ";
}


<body style="font-size:14px;background-color:aliceblue">
    <div class="div_gloser">
        <button class="btn-gloser" hidden="@IsRunning" id="btnOnStartBatch" name="btnOnStartBatch" @onclick="OnStartBatch">Start</button>
        <button class="btn-gloser" id="btnOnNextBatch" @onclick="OnNextBatch">Next</button>
        <button class="btn-gloser_long" hidden="@(!IsModeManual)" @onclick="@(()=> @OnShowAll())">@StrToLang</button>
        <button class="btn-gloser" hidden="@(!IsRunning)" @onclick=@(x=>OnAutoNextStop())>Stop</button>
        <button class="btn-gloser_long" hidden="@IsRunning" @onclick="OnSetup">Setup</button>
    </div>


    @if (lstWords == null)
    {
        <p><em>Loading Gloser ... </em></p>
    }
    else
    {
        <table class="blueTable">
            <thead>
                <tr>
                    <th style="width:40%"> @StrFromLang</th>
                    <th style="width:40%"> @StrToLang </th>
                    <th hidden="@(SingleMode)">
                        <button class="btn-gloser" @onclick="@(x=> @OnCorrAll())"> @(StrAllOk) </button>
                    </th>
                </tr>
            </thead>
            <tbody>
                @{
                    foreach (var w in lstBatch)
                    {
                        int cz = FontSize();
                        <tr style=@("font-size:"+(cz).ToString()+"px")>
                            <td>@w.FromWord</td>
                            <td class=@(ColCorrect(w)) @onclick="@(()=> @OnCorr(w))"> @w.ToWordAns</td>
                            <td hidden="@(SingleMode)">
                                <input type="checkbox" id="w.Correct" @bind="w.IsCorrect" />
                                <label for="@w.IsCorrect">OK</label>
                            </td>
                        </tr>
                    }
                }
            </tbody>
            <tfoot>
            </tfoot>
        </table>
    }
    <br />
    <h5 class="alert-info">@CorrectWordInfo</h5>
    <h5 class="alert-info">@WordInfo</h5>
    <h6 style="color:brown;font-style:italic">Message :@strMsg - Version: @__version</h6>
</body>

@code {
    string strMsg = "";

    private List<TWord> lstWords = new();
    private List<TWord> lstDict = new();
    private List<TWord> lstBatch = new();

    private static Timer timerM;
    private static TimerMsg timerMsg;
    private int msInterval = 500;
    private int sec;

    private int iWord = 0;
    private int iBatch = 0;

    private int randTot = 0;
    private int randCorr = 0;

    int NBMin { get => iWord + 1; }
    int NBMax { get => Math.Min(NBMin + dt.NumBatch - 1, NTotal); }

    private static Gloser __this = null;
    public static Gloser GetGloser() => __this;

    private bool IsModeManual { get => (dt.Mode == Mode.All_Man); }
    public bool IsRunning { get => (timerM?.Enabled ?? false) || (timerMsg?.Enabled ?? false); }
    public bool NoTimer { get => (dt.Mode == Mode.All_Man || dt.Mode == Mode.All_Now); }
    public bool HideNextStop { get => dt.Auto == Auto.Manual; }
    public bool SingleMode { get => dt.NumBatch == 1; }
    public static bool X { get => true == true; }
    private void OnSetup() => NavigationManager?.NavigateTo("Setup");
    public string StrAllOk { get => _bAllOk ? "All Ok" : "Non Ok"; }


    private int NTotal
    {
        get
        {
            return lstWords?.Count ?? 0;
        }
    }

    private int FontSize() =>
    dt.NumBatch switch
    {
        1 => 24,
        2 or 3 or 4 => 20,
        5 or 6 => 18,
        _ => 14
    };

    private string CorrectWordInfo => dt.Order switch
    {
        Order.Sequental =>
        string.Format("Correct {0} of {1}. Total : {2}", NCorrect, NBMax, NTotal),
        Order.Random =>
        string.Format("Correct {0} of Total : {1}", (randCorr + NBatchCorrect), randTot),
        _ => ""
    };

    private string WordInfo => dt.Order switch
    {
        Order.Random =>
            string.Format("Random - Using Words from {0} - {1}", dt.IdxStart, dt.IdxStart + dt.Step),
        Order.Sequental =>
            string.Format("Sequental - Showing {0}-{1} (Words {2}-{3})",
                       dt.IdxStart + iWord + 1, dt.IdxStart + iWord + lstBatch?.Count ?? 0,
                       dt.IdxStart + 1, dt.IdxStart + dt.Step),
        _ => ""
    };

    private void OnLangChoise(LangToFrom? choise = null)
    {
        dt.LangToFrom = choise ?? dt.LangToFrom;

        lstWords?.ForEach(o =>
        {
            (o.FromWord, o.ToWord) =
                dt.LangToFrom switch
                {
                    LangToFrom.EngSpa => (o.English, o.Spanish),
                    LangToFrom.SpaEng => (o.Spanish, o.English),
                    LangToFrom.NorSpa => (o.Norwegian, o.Spanish),
                    LangToFrom.SpaNor => (o.Spanish, o.Norwegian),
                    _ => (null, null)
                };
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        __this = this;
        TWord[] aWord = null;
        strMsg = __version;
        try
        {
            await LoadParams();
            aWord = await AccountService.GetDefaultDictionary();
            lstDict = aWord?.ToList<TWord>();
            lstDict.ForEach(o => (o.Norwegian, o.Spanish, o.English)
            = (o.Norwegian.ToLower(), o.Spanish.ToLower(), o.English.ToLower()));

            //int idxStart = dt.IdxStart;

            //for (int i = idxStart; i < idxStart + dt.Step; i++)
            //    lstWords.Add(lstDict[i]);
            lstWords.AddMany(lstDict, dt.IdxStart, dt.IdxStart+dt.Step-1);

            OnLangChoise();
            if (AccountService.IsServerDown)
                strMsg = "No contact with server, Using Default Dictionary";

        }
        catch (Exception e)
        {
            strMsg = "Error - unable to connect to the Server : " + e.Message;
            OnLangChoise();
        }

        timerM = new Timer();
        timerM.Elapsed += new ElapsedEventHandler(OnTimer2);
        timerM.Interval = msInterval;

        timerMsg = new TimerMsg();
        timerMsg.Elapsed += new ElapsedEventHandler(Timer_Msg);

        StateHasChanged();
    }

    private class TimerMsg : Timer
    {
        public enum Msg { Start, Next };
        public Msg _msg;
        public void PostOnMsg(Msg msg)
        {
            _msg = msg;
            Interval = msg == Msg.Start ? 10 : (int)Gloser.GetData().Auto;
            Start();
        }
    }

    void Timer_Msg(object o, ElapsedEventArgs e)
    {
        timerMsg.Stop();
        if (timerMsg._msg == TimerMsg.Msg.Next)
            OnNextBatch();
        if (timerMsg._msg == TimerMsg.Msg.Start)
            OnStartBatch();
    }

    void Reset()
    {
        iWord = 0;
        iBatch = 0;
        _bAllOk = true;
        lstWords.ForEach(o => o.ToWordAns = "");
        lstWords.ForEach(o => o.IsCorrect = false);
        timerM.Stop();
    }

    void OnStartBatch()
    {
        if (lstWords == null)
            return;

        Reset();

        if (dt.Mode == Mode.OneByOne ||
        dt.Mode == Mode.Scrolling ||
        dt.Mode == Mode.All_Time)
            timerM.Start();

        if (dt.Order == Order.Random)
        {
            randTot = dt.NumBatch;
            randCorr = 0;
        }

        sec = dt.SecThink;
        CopyToBatch();
        if (dt.Mode == Mode.All_Now)
            ShowAll();
        StateHasChanged();
    }

    void OnNextBatch()
    {
        _bAllOk = true;
        if (timerM.Enabled)
            timerM.Stop();

        if (dt.Order == Order.Sequental)
        {
            int iNew = Math.Min(iWord + dt.NumBatch, NTotal - 1);
            if (iNew == NTotal - 1)
                return;
            iWord = iNew;
        }

        if (dt.Order == Order.Random)
        {
            randTot += dt.NumBatch;
            randCorr += NBatchCorrect;
            lstWords.ForEach(o => o.IsCorrect = false);
        }

        iBatch = 0;
        CopyToBatch();
        sec = dt.SecThink;

        if (dt.Mode == Mode.All_Now)
            ShowAll();
        if (dt.Mode == Mode.OneByOne || dt.Mode == Mode.Scrolling || dt.Mode == Mode.All_Time)
            timerM.Start(); //PostOnMsg(TimerMsg.Msg.Next);
        StateHasChanged();
    }


    int iMax = 0, iMin = 0;
    void CopyToBatch()
    {
        lstBatch = new List<TWord>
            ();
        lstWords.ForEach(o => o.ToWordAns = "");
        if (dt.Order == Order.Sequental)
        {
            iMin = iWord;
            iMax = Math.Min(NTotal, iWord + dt.NumBatch);
            // foreach (var o in lstWords.Where(o => o.ID > iWord && o.ID <= iMax))
            for (int i = iMin; i < iMax; i++)
                lstBatch.Add(lstWords[i]);
        }
        if (dt.Order == Order.Random)
        {
            lstBatch = new List<TWord>
                ();
            Random r = new Random();
            while (lstBatch?.Count < dt.NumBatch)
            {
                int idx = r.Next(NTotal - 1);
                TWord w = lstWords[idx];
                if (!lstBatch.Exists(o => o.FromWord == w.FromWord))
                    lstBatch.Add(w);
            }
        }

    }

    void OnTimer2(object sender, ElapsedEventArgs e)
    {
        if (iBatch >= dt.NumBatch)
            return;
        if (dt.Mode == Mode.OneByOne || dt.Mode == Mode.Scrolling)
            OneAtATime();
        if (dt.Mode == Mode.All_Time)
            ShowAllTime();
        StateHasChanged();
    }

    void OneAtATime()
    {
        sec -= msInterval;
        if (sec > 0)
        {
            lstBatch[iBatch].ToWordAns = sec.ToString();
            return;
        }
        sec = dt.SecThink;
        lstBatch[iBatch].ToWordAns = lstBatch[iBatch].ToWord;
        iBatch++;
        if (iBatch >= dt.NumBatch)
        {
            timerM.Stop();
            if (dt.Auto == Auto.Manual)
                return;
            timerMsg.PostOnMsg(TimerMsg.Msg.Next);
        }
    }

    void ShowAllTime()
    {
        sec -= msInterval;
        if (sec > 0)
        {
            lstBatch.ForEach(o => o.ToWordAns = sec.ToString());
            iBatch = 0;
            return;
        }
        ShowAll();
        sec = dt.SecThink;
        timerM.Stop();
        if (dt.Auto == Auto.Manual)
            return;
        timerMsg.PostOnMsg(TimerMsg.Msg.Next);
    }

    public void OnAutoNextStop()
    {
        timerMsg.Stop();
        timerM.Stop();
        strMsg = "Stopped timers !";
    }

    void OnShowAll() => ShowAll();

    void ShowAll() => lstBatch.ForEach(o => o.ToWordAns = o.ToWord);


    public int NBatchCorrect
    {
        get => lstBatch?.Where(o => o.IsCorrect).Count() ?? 0;
    }

    public int NCorrect
    {
        get => lstWords?.Where(o => o.IsCorrect).Count() ?? 0;
    }

    static private bool _bAllOk = true;
    public void OnCorrAll()
    {
        lstBatch.ForEach(o => o.IsCorrect = _bAllOk);
        _bAllOk = !_bAllOk;
    }


    public void OnCorr(TWord w)
    {
        int tmp;
        if (w.ToWordAns.Length == 0)
            return;

        if (int.TryParse(w.ToWordAns, out tmp) == false)
            w.IsCorrect = !w.IsCorrect;
    }

    public string ColCorrect(TWord w) => w.IsCorrect ? "word_correct" : "";



}




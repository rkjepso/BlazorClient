@page "/gloser/{State}"
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

@using WebGloser.Model;
@using System.Timers;
@using BlazorClient.Services;
@using static BlazorClient.Shared.Misc;
@using BlazorClient.Model;

@code {
    string __version = "2.6.0: ";
    public string _state;

    [Parameter]
    public string State
    {
        get
        {
            return _state;
        }
        set
        {
            Reset();
            _state = value;
        }
    }

    public string StrStateSav;
}


<body style="font-size:14px;background-color:aliceblue">
    <h1>@State</h1>

    <div class="div_gloser">
        <button class="btn-gloser" hidden="@IsRunning" id="btnOnStartBatch" name="btnOnStartBatch" @onclick="OnStartBatch">Start</button>
        <button class="btn-gloser" id="btnOnNextBatch" @onclick="OnNextBatch">Next</button>
        <button class="btn-gloser_long" hidden="@(!IsModeManual)" @onclick="@(()=> @OnShowAll())">@StrToLang</button>
        <button class="btn-gloser" hidden="@(!IsRunning)" @onclick=@(x=>OnAutoNextStop())>Stop</button>
        <button class="btn-gloser_long" hidden="@IsRunning" @onclick="OnSetup">Setup</button>
    </div>


    @if (lstWords == null)
    {
        <p><em>Loading Gloser ... </em></p>
    }
    else
    {
        <table class="blueTable">
            <thead>
                <tr>
                    <th style="width:45%"> @StrFromLang</th>
                    <th style="width:55%" @onclick="@(x=> @OnCorrAll())"> @StrToLang </th>
                </tr>
            </thead>
            <tbody>
                @{
                    foreach (var w in lstBatch)
                    {
                        int cz = FontSize();
                        <tr style=@("font-size:"+(cz).ToString()+"px")>
                            <td>@w.FromWord</td>
                            <td class=@(ColCorrect(w)) @onclick="@(()=> @OnCorr(w))"> @w.ToWordAns</td>
                        </tr>
                    }
                }
            </tbody>
            <tfoot>
            </tfoot>
        </table>
    }
    <br />
    <h6 class="badge-light">@WordInfo</h6>
    <h6 class="alert-info">@CorrectWordInfo</h6>
    <h6 style="color:brown;font-style:italic">@strMsg - Version: @__version</h6>
</body>

@code {
    string strMsg = "";

    private List<TWord> lstWords = new();
    private List<TWord> lstDict = new();
    private List<TWord> lstBatch = new();

    private Timer timerW;
    private TimerMsg timerMsg;
    private int msInterval = 500;
    private int sec;

    private int iWord = 0;
    private int iBatch = 0;

    private int randTot = 0;
    private int randCorr = 0;

    int NBMin { get => iWord + 1; }
    int NBMax { get => Math.Min(NBMin + Cfg.NumBatch - 1, TotalWords); }

    private static Gloser __this = null;
    public static Gloser GetGloser() => __this;

    private bool IsModeManual { get => (Cfg.Mode == Mode.All_Man); }
    public bool IsRunning { get => (timerW?.Enabled ?? false) || (timerMsg?.Enabled ?? false); }
    public bool NoTimer { get => (Cfg.Mode == Mode.All_Man || Cfg.Mode == Mode.All_Now); }
    public bool HideNextStop { get => Cfg.Auto == Auto.Manual; }
    public bool SingleMode { get => Cfg.NumBatch == 1; }

    private void OnSetup() => NavigationManager?.NavigateTo("Setup");
    public string StrAllOk { get => _bAllOk ? "All Ok" : "Non Ok"; }


    private int TotalWords
    {
        get
        {
            return lstWords?.Count ?? 0;
        }
    }

    private int FontSize() =>
    Cfg.NumBatch switch
    {
        1 => 26,
        2 or 3 or 4 => 24,
        5 or 6 => 18,
        _ => 14
    };

    private string CorrectWordInfo => Cfg.Order switch
    {
        Order.Sequental =>
            string.Format("Correct {0} of {1}. Total : {2}", NumberCorrectWords, NBMax, TotalWords),
        Order.Random =>
            string.Format("Correct {0} of Total : {1}", (randCorr + NBatchCorrect), randTot),
        Order.Artif_Int =>
            string.Format("Remaing words {0} ", TotalWords - NBatchCorrect),
        _ => ""
    };

    private string WordInfo => Cfg.Order switch
    {
        Order.Artif_Int =>
            string.Format("AI Mode - Remove - Words from {0} - {1}", Cfg.IdxStart, Cfg.IdxStart + Cfg.Step),
        Order.Random =>
            string.Format("Random - Using Words from {0} - {1}", Cfg.IdxStart, Cfg.IdxStart + Cfg.Step),
        Order.Sequental =>
            string.Format("Sequental - Showing {0}-{1} (Words {2}-{3})",
                       Cfg.IdxStart + iWord + 1, Cfg.IdxStart + iWord + lstBatch?.Count ?? 0,
                       Cfg.IdxStart + 1, Cfg.IdxStart + Cfg.Step),
        _ => ""
    };

    private void OnLangChoise()
    {
        //    Cfg.LangToFrom = choise ?? Cfg.LangToFrom;

        lstWords?.ForEach(o =>
        {
            (o.FromWord, o.ToWord) =
                Cfg.LangToFrom switch
                {
                    LangToFrom.EngSpa => (o.English, o.Spanish),
                    LangToFrom.SpaEng => (o.Spanish, o.English),
                    LangToFrom.NorSpa => (o.Norwegian, o.Spanish),
                    LangToFrom.SpaNor => (o.Spanish, o.Norwegian),
                    _ => (null, null)
                };
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        __this = this;
        TWord[] aWord = null;
        strMsg = __version;
        InitTimers();
        try
        {
            strMsg = "Contaction server ...";

            StateHasChanged();

            await LoadParams();

            aWord = await AccountService.GetDefaultDictionary();
            lstDict = aWord?.ToList<TWord>();
            lstDict.ForEach(o => (o.Norwegian, o.Spanish, o.English)
            = (o.Norwegian.ToLower(), o.Spanish.ToLower(), o.English.ToLower()));

            lstWords.AddMany(lstDict, Cfg.IdxStart, Cfg.IdxStart + Cfg.Step - 1);

            OnLangChoise();
            if (AccountService.IsServerDown)
                strMsg = "No contact with server, Using Default Dictionary";
            else
                strMsg = "Loaded words from server OK.";

        }
        catch (Exception e)
        {
            strMsg = "Error - unable to connect to the Server : " + e.Message;
            OnLangChoise();
        }



        StateHasChanged();

        void InitTimers()
        {
            timerW = new Timer();
            timerW.Elapsed += new ElapsedEventHandler(OnTimerWord);
            timerW.Interval = msInterval;

            timerMsg = new TimerMsg();
            timerMsg.Elapsed += new ElapsedEventHandler(Timer_Msg);
        }
    }

    private class TimerMsg : Timer
    {
        public enum Msg { Start, Next };
        public Msg _msg;
        public void PostOnMsg(Msg msg)
        {
            _msg = msg;
            Interval = msg == Msg.Start ? 10 : (int)Gloser.GetData().Auto;
            Start();
        }
    }

    void Timer_Msg(object o, ElapsedEventArgs e)
    {
        timerMsg.Stop();
        if (timerMsg._msg == TimerMsg.Msg.Next)
            OnNextBatch();
        if (timerMsg._msg == TimerMsg.Msg.Start)
            OnStartBatch();
    }

    void Reset()
    {
        iWord = 0;
        iBatch = 0;
        _bAllOk = true;

        lstWords?.Clear();
        lstWords?.AddMany(lstDict, Cfg.IdxStart, Cfg.IdxStart + Cfg.Step - 1);

        lstWords?.ForEach(o => o.ToWordAns = "");
        lstWords?.ForEach(o => o.IsCorrect = false);
        lstBatch?.Clear();
        timerW?.Stop();

        StateHasChanged();
    }

    void OnStartBatch()
    {
        if (lstWords == null)
            return;

        Reset();

        if (Cfg.Mode == Mode.OneByOne ||
        Cfg.Mode == Mode.Scrolling ||
        Cfg.Mode == Mode.All_Time)
            timerW.Start();

        if (Cfg.Order == Order.Random || Cfg.Order == Order.Artif_Int)
        {
            randTot = Cfg.NumBatch;
            randCorr = 0;
        }

        sec = Cfg.SecThink;
        CopyToBatch();
        if (Cfg.Mode == Mode.All_Now)
            ShowAll();
        StateHasChanged();
    }

    void OnNextBatch()
    {
        _bAllOk = true;
        if (timerW.Enabled)
            timerW.Stop();

        if (Cfg.Order == Order.Sequental)
        {
            int iNew = Math.Min(iWord + Cfg.NumBatch, TotalWords - 1);
            if (iNew == TotalWords - 1)
            {
                if (State==strPageTesting)
                    OnReportTest();
                return;
            }

            iWord = iNew;
        }

        if (Cfg.Order == Order.Random || Cfg.Order == Order.Artif_Int)
        {
            randTot += Cfg.NumBatch;
            randCorr += NBatchCorrect;
        }

        iBatch = 0;
        CopyToBatch();
        if (lstWords.Count == 0)
        {
            StateHasChanged();
            return;
        }
        sec = Cfg.SecThink;

        if (Cfg.Mode == Mode.All_Now)
            ShowAll();
        if (Cfg.Mode == Mode.OneByOne || Cfg.Mode == Mode.Scrolling || Cfg.Mode == Mode.All_Time)
            timerW.Start(); //PostOnMsg(TimerMsg.Msg.Next);
        StateHasChanged();
    }


    int iMax = 0, iMin = 0;
    void CopyToBatch()
    {
        lstBatch = new();

        lstWords.ForEach(o => o.ToWordAns = "");
        if (Cfg.Order == Order.Sequental)
        {
            iMin = iWord;
            iMax = Math.Min(TotalWords, iWord + Cfg.NumBatch);
            lstBatch.AddMany(lstWords, iMin, iMax - 1);
        }

        if (Cfg.Order == Order.Random || Cfg.Order == Order.Artif_Int)
        {
            if (Cfg.Order == Order.Artif_Int) // Remove the word that is correct
                lstWords = lstWords.Where(w => w.IsCorrect == false).ToList();

            lstWords.ForEach(o => o.IsCorrect = false);
            lstBatch = new List<TWord>();
            if (lstWords.Count <= Cfg.NumBatch)
                lstBatch.AddMany(lstWords, 0, Cfg.NumBatch - 1);
            else
                AddBatchWithRandomWords();
        }

        void AddBatchWithRandomWords()
        {
            Random r = new Random();
            while (lstBatch?.Count < Cfg.NumBatch)
            {
                int idx = r.Next(TotalWords);
                TWord w = lstWords[idx];
                if (!lstBatch.Exists(o => o.FromWord == w.FromWord))
                    lstBatch.Add(w);
            }
        }
    }


    void OnTimerWord(object sender, ElapsedEventArgs e)
    {
        if (iBatch >= Cfg.NumBatch)
            return;
        if (Cfg.Mode == Mode.OneByOne || Cfg.Mode == Mode.Scrolling)
            OneAtATime();
        if (Cfg.Mode == Mode.All_Time)
            ShowAllTime();
        StateHasChanged();
    }

    void OneAtATime()
    {
        sec -= msInterval;
        if (sec > 0)
        {
            lstBatch[iBatch].ToWordAns = sec.ToString();
            return;
        }
        sec = Cfg.SecThink;
        lstBatch[iBatch].ToWordAns = lstBatch[iBatch].ToWord;
        iBatch++;
        if (iBatch >= Cfg.NumBatch)
        {
            timerW.Stop();

            if (Cfg.Auto == Auto.Manual)
                return;
            timerMsg.PostOnMsg(TimerMsg.Msg.Next);
        }

        // Keep continuing if AI
        if (Cfg.Order == Order.Artif_Int && lstWords.Count <= Cfg.NumBatch)
            timerMsg.PostOnMsg(TimerMsg.Msg.Next);
    }

    void ShowAllTime()
    {
        sec -= msInterval;
        if (sec > 0)
        {
            lstBatch.ForEach(o => o.ToWordAns = sec.ToString());
            iBatch = 0;
            return;
        }
        ShowAll();
        sec = Cfg.SecThink;
        timerW.Stop();
        if (Cfg.Auto == Auto.Manual)
            return;
        timerMsg.PostOnMsg(TimerMsg.Msg.Next);
    }

    public void OnAutoNextStop()
    {
        timerMsg.Stop();
        timerW.Stop();
        strMsg = "Stopped timers !";
    }

    void OnShowAll() => ShowAll();

    void ShowAll() => lstBatch.ForEach(o => o.ToWordAns = o.ToWord);


    public int NBatchCorrect
    {
        get => lstBatch?.Where(o => o.IsCorrect).Count() ?? 0;
    }

    public int NumberCorrectWords
    {
        get => lstWords?.Where(o => o.IsCorrect).Count() ?? 0;
    }

    static private bool _bAllOk = true;
    public void OnCorrAll()
    {
        lstBatch.ForEach(o => o.IsCorrect = _bAllOk);
        timerW.Stop();
        timerMsg.Stop();
        timerMsg.PostOnMsg(TimerMsg.Msg.Next);
        _bAllOk = !_bAllOk;
    }


    public void OnCorr(TWord w)
    {
        int tmp;
        if (w.ToWordAns.Length == 0)
            return;

        if (int.TryParse(w.ToWordAns, out tmp) == false)
            w.IsCorrect = !w.IsCorrect;
    }

    private void OnReportTest()
    {
        Test t = new();
        t.Dt = DateTime.Now;
        t.Name = string.Format("Words {0} - {1}", iMin, iMax);
        t.Score = NumberCorrectWords;
        t.MaxScore = lstWords.Count;
        AddTest(t);
    }



    public string ColCorrect(TWord w) => w.IsCorrect ? "word_correct" : "";
}



